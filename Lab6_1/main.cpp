
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//																																				//
// Author               : pt206																													//
// Day 				    : 04.06.2019																											//
// file name            : main.cpp																												//
//																																				//
// ---------------------------------------------------------------------------------------------------------------------------------------------//
// A																																			//
//              _____           _      _     _ _																								//
//             /  __ \         | |    | |   (_) |																								//
//             | /  \/ ___   __| | ___| |    _| |_ ___																							//
//             | |    / _ \ / _  |/ _ \ |   | | __/ _ )																							//
//             | \__/\ (_) | (_| |  __/ |___| | ||  __/																							//
//              \____/\___/ \__,_|\___\_____/_|\__\___|																							//
//																																				//
//                                                  F i l e																						//
//																																				//
//	1. Реализовать алгоритм сортировки (алгоритм выбрать самостоятельно) в виде шаблонной функции.												//
//	Продемонстрировать работу шаблонной функции на массивах различных типов.																	//
//	2. Реализовать   класс   Rectangle   с   атрибутами,   хранящими   высоту   и   ширину,   и   поддерживающий								//
//	сравнение   по   площади.   Продемонстрировать   сортировку   массива   объектов   типа   Rectangle											//
//	шаблонной функцией, разработанной в предыдущем задании. 																					//
//	3. Реализовать   шаблонный   класс   DoubleBox   для   хранения   двух   атрибутов   разного   типа.   Тип									//
//	атрибутов   задать   параметрами   шаблона.   Реализовать   в   классе   конструктор   по   умолчанию,										//
//	инициализирующий конструктор, а также методы get и set.																						//
//	4. Задание   повышенной   сложности.   Реализовать   шаблонный   класс   Array   для   хранения   массива									//
//	произвольного типа и размера (без использования динамической памяти). Тип элементов и размер												//
//	массива задать параметрами шаблона. Реализовать в классе следующие конструкторы: 															//
//		конструктор по-умолчанию, без параметров; 																								//
//		конструктор, позволяющий инициализировать весь внутренний массив одинаковыми значениями, 												//
//		имеющий один параметр — инициализирующее значение;																						//
//		конструктор,  позволяющий инициализировать внутренний массив значениями из внешнего массива, 											//
//		имеющий два параметра — указатель на внешний массив и размер внешнего массива.															//
//	Реализовать в классе Array перегрузку оператора индексации operator[], 																		//
//	для того чтобы можно было применять его к экземплярам класса для выполнения обращения к элементам внутреннего массива.   					//
//	Проверить работоспособность оператора индексации для константных объектов, 																	//
//	а также работоспособность при использовании слева от оператора присваивания.																//
//																																				//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>

using namespace std;

#define maxn 100

template <typename T> void merge(T * a, int l, int r) {

    if (r == l) return;
    if (r - l == 1) { if (a[r] < a[l]) swap(a[r], a[l]); return; }
	
    int m = (r + l) / 2; 
	merge(a, l, m);
    merge(a, m + 1, r);
	
	T * buf =  new T[5];
	int cur = 0;
	int xl = l;
	int xr = m+1;
	while (r-l+1 != cur) {
		if (xl > m) 
			buf[cur++] = a[xr++];
        else if (xr > r) 
			buf[cur++] = a[xl++];
        else if (a[xl] > a[xr])	
			buf[cur++] = a[xr++];
        else 
			buf[cur++] = a[xl++];
	}
    for (int i = 0; i < cur; i++) { a[i + l] = buf[i]; }	
	delete[] buf;
}

int main() {    
	int * a = new int[maxn];
    int n; cin >> n;

    for (int i = 0; i < n; i++)
        cin >> a[i];

    merge(a, 0, n - 1);

    for (int i = 0; i < n; i++)
        cout << a[i] << " ";
	cout << endl;
    return 0;
}